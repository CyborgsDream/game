<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Game Hub v0.22</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      font-family: sans-serif;
      background: radial-gradient(circle at 20% 30%, #1c2a52, #0a0f1f 60%),
        radial-gradient(circle at 80% 10%, #243b68, transparent 50%),
        linear-gradient(135deg, #0a1029, #09101d 70%, #04060f);
      background-color: #04060f;
      color: #fff;
      text-align: center;
      overflow-x: hidden;
      overflow-y: auto;
      touch-action: pan-y;
      -webkit-overflow-scrolling: touch;
      box-sizing: border-box;
    }

    main {
      width: 100vw;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 0;
      padding: 0;
      background: rgba(0, 8, 20, 0.58);
      box-shadow: none;
      backdrop-filter: blur(6px);
      border-radius: 0;
    }

    h1 {
      font-size: clamp(2.85rem, 4.8vw, 4.5rem);
      letter-spacing: 3px;
      margin: 0;
      text-transform: uppercase;
      color: #d4e6ff;
      text-shadow: 0 0 10px rgba(76, 168, 255, 0.9), 0 0 24px rgba(0, 180, 255, 0.45), 0 12px 32px rgba(0, 0, 0, 0.6);
      position: relative;
    }

    h1::after {
      content: '';
      position: absolute;
      left: 50%;
      bottom: -12px;
      transform: translateX(-50%);
      width: 160px;
      height: 3px;
      background: linear-gradient(90deg, transparent, rgba(0, 200, 255, 0.9), transparent);
      box-shadow: 0 0 14px rgba(0, 200, 255, 0.75);
    }

    .canvas-frame {
      position: relative;
      width: 100vw;
      height: 100vh;
      min-height: 360px;
      overflow: hidden;
      box-shadow: none;
      background: linear-gradient(135deg, rgba(20, 35, 70, 0.85), rgba(10, 18, 36, 0.85));
      border-radius: 0;
    }

    .fullscreen-toggle {
      position: absolute;
      top: 0.65rem;
      right: 0.65rem;
      padding: 0.45rem 0.8rem;
      background: rgba(0, 0, 0, 0.45);
      border: 1px solid rgba(0, 200, 255, 0.35);
      color: #d4e6ff;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.95rem;
      letter-spacing: 0.35px;
      backdrop-filter: blur(6px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
      transition: transform 0.2s ease, border-color 0.2s ease, color 0.2s ease;
      pointer-events: auto;
    }

    .fullscreen-toggle:hover,
    .fullscreen-toggle:focus-visible {
      transform: translateY(-1px) scale(1.01);
      border-color: rgba(0, 200, 255, 0.7);
      color: #fff;
      outline: none;
    }

    #bg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .vector-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: screen;
      opacity: 0.78;
      filter: drop-shadow(0 0 12px rgba(0, 200, 255, 0.35));
    }

    .vector-overlay svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .grid-layer rect {
      fill: url(#neon-grid);
      opacity: 0.55;
      filter: blur(0.35px);
      animation: grid-flicker 6.5s ease-in-out infinite;
    }

    .grid-layer .axis {
      stroke: rgba(0, 230, 255, 0.75);
      stroke-width: 0.6;
      stroke-linecap: round;
      filter: drop-shadow(0 0 6px rgba(0, 200, 255, 0.45));
      animation: axis-pulse 5.5s ease-in-out infinite;
    }

    .wired-paths polyline {
      stroke: rgba(255, 128, 196, 0.9);
      stroke-width: 0.9;
      stroke-linecap: round;
      stroke-linejoin: round;
      fill: none;
      filter: blur(0.4px) drop-shadow(0 0 10px rgba(255, 128, 196, 0.35));
      stroke-dasharray: 18 12;
      animation: wire-glow 7s ease-in-out infinite;
    }

    .wired-paths polyline:nth-child(2) {
      stroke: rgba(130, 210, 255, 0.9);
      stroke-dasharray: 16 9;
      animation-duration: 6.4s;
    }

    .wired-paths polyline:nth-child(3) {
      stroke: rgba(0, 255, 205, 0.75);
      stroke-dasharray: 14 10;
      animation-duration: 8.2s;
    }

    @keyframes grid-flicker {
      0% {
        opacity: 0.35;
        filter: blur(0.7px);
      }
      30% {
        opacity: 0.55;
        filter: blur(0.3px);
      }
      55% {
        opacity: 0.72;
        filter: blur(0.1px);
      }
      100% {
        opacity: 0.4;
        filter: blur(0.6px);
      }
    }

    @keyframes axis-pulse {
      0%,
      100% {
        opacity: 0.75;
      }
      50% {
        opacity: 0.45;
        stroke-width: 0.45;
      }
    }

    @keyframes wire-glow {
      0% {
        opacity: 0.2;
        stroke-dashoffset: 0;
        filter: blur(0.7px) drop-shadow(0 0 12px rgba(255, 128, 196, 0.45));
      }
      40% {
        opacity: 0.68;
        stroke-dashoffset: -22;
        filter: blur(0.35px) drop-shadow(0 0 14px rgba(255, 128, 196, 0.55));
      }
      70% {
        opacity: 0.5;
        stroke-dashoffset: -36;
        filter: blur(0.55px) drop-shadow(0 0 18px rgba(255, 128, 196, 0.35));
      }
      100% {
        opacity: 0.26;
        stroke-dashoffset: -12;
      }
    }

    .cta-buttons {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.65rem;
      pointer-events: none;
      padding: 0.5rem;
    }

    .info {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0;
      max-width: 780px;
      padding: 1rem 1.25rem 1.5rem;
    }

    p {
      margin: 0;
      color: #c8d7ff;
      letter-spacing: 0.3px;
      text-shadow: 0 0 12px rgba(100, 180, 255, 0.35);
    }

    .cta-buttons a {
      pointer-events: auto;
      display: inline-block;
      padding: 0.55rem 1.2rem;
      background: linear-gradient(120deg, #ff9800, #ff5722 40%, #ff3d7f);
      color: #fff;
      text-decoration: none;
      font-size: 1.05rem;
      letter-spacing: 0.5px;
      transition: transform 0.25s ease, box-shadow 0.25s ease, background 0.3s;
      box-shadow: 0 8px 22px rgba(255, 87, 34, 0.3);
      border-radius: 10px;
      min-width: 9rem;
      width: min(18rem, 90vw);
      text-align: center;
    }

    .cta-buttons a:hover {
      background: linear-gradient(120deg, #ffc107, #ff7043 40%, #ff4da6);
      transform: translateY(-1px) scale(1.01);
      box-shadow: 0 12px 28px rgba(255, 105, 71, 0.4);
    }

    .cta-buttons a.secondary {
      background: linear-gradient(120deg, #4fc3f7, #00bcd4 40%, #5c6bc0);
      box-shadow: 0 8px 22px rgba(0, 188, 212, 0.28);
    }

    .cta-buttons a.secondary:hover {
      background: linear-gradient(120deg, #81d4fa, #26c6da 40%, #7986cb);
      box-shadow: 0 12px 28px rgba(0, 188, 212, 0.4);
    }

    h2 {
      margin: 0;
      font-size: clamp(2rem, 3.8vw, 3rem);
      letter-spacing: 0.08em;
      text-shadow: 0 0 16px rgba(76, 168, 255, 0.35);
    }

    @media (max-width: 980px) {
      body {
        align-items: flex-start;
      }

      main {
        gap: 0.5rem;
      }

      h1 {
        letter-spacing: 2px;
      }

      .canvas-frame {
        height: 82vh;
        min-height: 320px;
      }

      .cta-buttons {
        gap: 0.55rem;
      }

      .fullscreen-toggle {
        top: 0.55rem;
        right: 0.55rem;
        font-size: 0.9rem;
        padding: 0.4rem 0.7rem;
      }

      .cta-buttons a {
        font-size: 1rem;
        padding: 0.65rem 1.1rem;
      }

    }

    @media (max-width: 540px) {
      main {
        border-radius: 0;
      }

      h1 {
        font-size: clamp(2.15rem, 9vw, 3.2rem);
        letter-spacing: 1.5px;
      }

      .canvas-frame {
        height: 70vh;
        min-height: 260px;
        border-radius: 0;
      }

      .cta-buttons {
        padding: 0.75rem;
      }

      .fullscreen-toggle {
        top: 0.5rem;
        right: 0.5rem;
        font-size: 0.85rem;
      }

      .cta-buttons a {
        width: 100%;
        max-width: 360px;
      }

      p {
        font-size: 0.98rem;
      }
    }
  </style>
</head>
<body>
  <main>
    <h1>Neon Game Hub</h1>
    <div class="canvas-frame">
      <button class="fullscreen-toggle" type="button" aria-pressed="false">Enter Fullscreen</button>
      <canvas id="bg"></canvas>
      <div class="vector-overlay" aria-hidden="true">
        <svg viewBox="0 0 100 100" preserveAspectRatio="none">
          <defs>
            <pattern id="neon-grid" width="8" height="8" patternUnits="userSpaceOnUse">
              <path d="M0 0 L0 8 M0 0 L8 0" fill="none" stroke="rgba(0, 200, 255, 0.5)" stroke-width="0.3" />
            </pattern>
          </defs>
          <g class="grid-layer">
            <rect x="0" y="0" width="100" height="100"></rect>
            <line class="axis" x1="0" y1="50" x2="100" y2="50"></line>
            <line class="axis" x1="50" y1="0" x2="50" y2="100"></line>
          </g>
          <g class="wired-paths">
            <polyline points="8,72 22,60 38,66 52,52 74,62 88,50"></polyline>
            <polyline points="12,32 30,22 48,30 62,18 82,26 90,16"></polyline>
            <polyline points="6,46 18,40 28,48 44,34 58,40 70,30 86,36"></polyline>
          </g>
        </svg>
      </div>
      <div class="cta-buttons">
        <a class="play-button" href="game.html">Play Now</a>
        <a class="secondary" href="terrain.html">Explorer Mode</a>
        <a class="secondary" href="arena.html">Arena Mode</a>
      </div>
    </div>
    <div class="info">
      <p>Prepare yourself for an immersive 3D experience.</p>
    </div>
  </main>
  <script>
    const canvas = document.getElementById('bg');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050913, 0.035);

    const camera = new THREE.PerspectiveCamera(62, 1, 0.1, 180);
    camera.position.set(0, 8, 18);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.35));
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;

    const clock = new THREE.Clock();
    const root = new THREE.Group();
    scene.add(root);

    // Atmosphere + light
    const ambient = new THREE.AmbientLight(0x5fb1ff, 0.4);
    scene.add(ambient);

    const mainLight = new THREE.PointLight(0xffbf7f, 2.8, 120, 1.8);
    mainLight.position.set(-12, 18, 10);
    scene.add(mainLight);

    const rimLight = new THREE.PointLight(0x6ac7ff, 1.4, 90, 2);
    rimLight.position.set(14, 10, -12);
    scene.add(rimLight);

    function makeFlare(color) {
      const size = 256;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
      gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0.9)`);
      gradient.addColorStop(0.35, `rgba(${color.r}, ${color.g}, ${color.b}, 0.45)`);
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, size, size);
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(20, 20, 1);
      return sprite;
    }

    const warmFlare = makeFlare({ r: 255, g: 170, b: 100 });
    warmFlare.position.copy(mainLight.position).multiplyScalar(0.6);
    scene.add(warmFlare);

    const coolFlare = makeFlare({ r: 120, g: 190, b: 255 });
    coolFlare.position.copy(rimLight.position).multiplyScalar(0.65);
    scene.add(coolFlare);

    // Low-poly terrain
    const terrainGeometry = new THREE.PlaneGeometry(60, 60, 60, 60);
    const pos = terrainGeometry.attributes.position;
    for (let i = 0; i < pos.count; i++) {
      const x = pos.getX(i);
      const z = pos.getZ(i);
      const height = Math.sin(x * 0.22) * 1.6 + Math.cos(z * 0.18) * 1.2 + (Math.random() * 0.8 - 0.4);
      pos.setY(i, height);
    }
    pos.needsUpdate = true;
    terrainGeometry.computeVertexNormals();
    terrainGeometry.rotateX(-Math.PI / 2);

    const terrainMaterial = new THREE.MeshStandardMaterial({
      color: 0x0d203f,
      roughness: 0.95,
      metalness: 0.05,
      flatShading: true,
      emissive: 0x071022,
      emissiveIntensity: 0.4,
    });
    const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
    terrain.receiveShadow = true;
    root.add(terrain);

    // Crystal monoliths
    const crystals = new THREE.Group();
    const crystalMaterial = new THREE.MeshStandardMaterial({
      color: 0x1c8adb,
      emissive: 0x133d6a,
      emissiveIntensity: 0.65,
      metalness: 0.3,
      roughness: 0.25,
      flatShading: true,
    });

    const crystalSpin = [];
    for (let i = 0; i < 22; i++) {
      const geom = new THREE.DodecahedronGeometry(THREE.MathUtils.randFloat(0.35, 1.6), 0);
      const mesh = new THREE.Mesh(geom, crystalMaterial);
      const angle = Math.random() * Math.PI * 2;
      const radius = 6 + Math.random() * 18;
      const y = THREE.MathUtils.randFloat(0.3, 2.8);
      mesh.position.set(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
      mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
      crystalSpin.push(0.002 + Math.random() * 0.001);
      crystals.add(mesh);
    }
    root.add(crystals);

    // Floating shards
    const shardMaterial = new THREE.MeshStandardMaterial({
      color: 0xffc857,
      emissive: 0x753900,
      emissiveIntensity: 0.5,
      flatShading: true,
      metalness: 0.2,
      roughness: 0.4,
    });
    const shardGeometry = new THREE.TetrahedronGeometry(THREE.MathUtils.randFloat(0.12, 0.32), 0);
    const shardCount = 80;
    const shardMesh = new THREE.InstancedMesh(shardGeometry, shardMaterial, shardCount);
    shardMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    root.add(shardMesh);

    const shardStates = [];
    const shardDummy = new THREE.Object3D();
    for (let i = 0; i < shardCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const radius = 8 + Math.random() * 18;
      const baseY = THREE.MathUtils.randFloat(1.4, 8.5);
      shardDummy.position.set(Math.cos(angle) * radius, baseY, Math.sin(angle) * radius);
      shardDummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
      shardDummy.updateMatrix();
      shardMesh.setMatrixAt(i, shardDummy.matrix);
      shardStates.push({
        x: shardDummy.position.x,
        y: baseY,
        z: shardDummy.position.z,
        baseRot: shardDummy.rotation.clone(),
        floatSpeed: 1.2 + Math.random() * 0.8,
        floatAmp: THREE.MathUtils.randFloat(0.35, 0.9),
        spinX: 0.0035 + Math.random() * 0.0012,
        spinY: 0.0042 + Math.random() * 0.0014,
        offset: Math.random() * Math.PI * 2,
      });
    }

    // Star particles
    const starGeom = new THREE.BufferGeometry();
    const starCount = 180;
    const starPositions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount * 3; i += 3) {
      starPositions[i] = THREE.MathUtils.randFloatSpread(80);
      starPositions[i + 1] = THREE.MathUtils.randFloat(10, 40);
      starPositions[i + 2] = THREE.MathUtils.randFloatSpread(80);
    }
    starGeom.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const starMat = new THREE.PointsMaterial({ color: 0xcfe3ff, size: 0.2, transparent: true, opacity: 0.9, depthWrite: false });
    const stars = new THREE.Points(starGeom, starMat);
    root.add(stars);

    let lastWidth = 0;
    let lastHeight = 0;
    let needsResize = true;
    function sizeRendererToCanvas(force = false) {
      if (!force && !needsResize) return;
      const { width, height } = canvas.getBoundingClientRect();
      if (width !== lastWidth || height !== lastHeight || force) {
        lastWidth = width;
        lastHeight = height;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height, false);
      }
      needsResize = false;
    }

    sizeRendererToCanvas(true);
    window.addEventListener('resize', () => {
      needsResize = true;
    });

    // Fullscreen handling
    const fullscreenToggle = document.querySelector('.fullscreen-toggle');
    const fullscreenTarget = document.documentElement;

    function updateFullscreenLabel() {
      const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
      fullscreenToggle.textContent = isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen';
      fullscreenToggle.setAttribute('aria-pressed', isFullscreen ? 'true' : 'false');
    }

    fullscreenToggle.addEventListener('click', async () => {
      try {
        if (document.fullscreenElement || document.webkitFullscreenElement) {
          await (document.exitFullscreen || document.webkitExitFullscreen).call(document);
        } else {
          const request = fullscreenTarget.requestFullscreen || fullscreenTarget.webkitRequestFullscreen;
          if (request) {
            await request.call(fullscreenTarget);
          }
        }
      } catch (err) {
        console.error('Fullscreen toggle failed', err);
      }
    });

    document.addEventListener('fullscreenchange', updateFullscreenLabel);
    document.addEventListener('webkitfullscreenchange', updateFullscreenLabel);
    updateFullscreenLabel();

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const t = clock.elapsedTime;

      sizeRendererToCanvas();
      resizeArena();

      camera.position.x = Math.sin(t * 0.15) * 16;
      camera.position.z = Math.cos(t * 0.12) * 18;
      camera.position.y = 6 + Math.sin(t * 0.35) * 1.8;
      camera.lookAt(0, 2.5 + Math.sin(t * 0.2) * 0.5, 0);

      terrain.rotation.y = t * 0.0015;
      crystals.children.forEach((c, i) => {
        const spin = crystalSpin[i];
        c.rotation.y += spin;
        c.position.y += Math.sin(t * 0.65 + i) * 0.0012;
      });

      for (let i = 0; i < shardCount; i++) {
        const state = shardStates[i];
        const y = state.y + Math.sin(t * state.floatSpeed + state.offset) * state.floatAmp;
        shardDummy.position.set(state.x, y, state.z);
        shardDummy.rotation.set(
          state.baseRot.x + t * state.spinX,
          state.baseRot.y + t * state.spinY,
          state.baseRot.z
        );
        shardDummy.updateMatrix();
        shardMesh.setMatrixAt(i, shardDummy.matrix);
      }
      shardMesh.instanceMatrix.needsUpdate = true;

      const flarePulse = (Math.sin(t * 2.0) + 1) * 0.35 + 0.4;
      warmFlare.material.opacity = flarePulse;
      coolFlare.material.opacity = 0.3 + Math.sin(t * 1.3 + 1) * 0.25;

      stars.rotation.y += 0.0005;

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
