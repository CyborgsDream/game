<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GAME v0.22</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body,html{margin:0;padding:0;overflow:hidden;background:#000;}
    #sceneCanvas{display:block;width:100vw;height:100vh;}
    #permissionBtn{position:absolute;top:20px;left:20px;padding:10px 20px;font-family:sans-serif;font-size:16px;}
    #hud{position:absolute;top:10px;right:10px;color:#fff;font-family:sans-serif;font-size:14px;text-align:right;line-height:1.4;}
    #targetLock{position:absolute;width:20px;height:20px;border:2px solid red;border-radius:50%;pointer-events:none;display:none;}
    #energyBarContainer{position:absolute;top:20px;left:20px;width:300px;height:20px;border:2px solid #fff;background:#222;}
    #energyBar{height:100%;width:100%;background:hsl(120,100%,50%);transform-origin:left;}
  </style>
</head>
<body>
  <canvas id="sceneCanvas"></canvas>
  <button id="permissionBtn" style="display:none;">Enable Motion</button>
  <button id="calibrateBtn" style="display:none;top:60px;left:20px;position:absolute;padding:10px 20px;font-family:sans-serif;font-size:16px;">Calibrate</button>
  <button id="chargeBtn" style="position:absolute;bottom:20px;left:50%;transform:translateX(-50%);padding:10px 20px;font-family:sans-serif;font-size:16px;">Charge</button>
  <div id="targetLock"></div>
  <div id="energyBarContainer"><div id="energyBar"></div></div>
  <div id="hud">
    <div id="orientDisplay"></div>
    <div id="fpsDisplay"></div>
    <div id="stepsDisplay"></div>
    <div id="energyDisplay"></div>
  </div>
  <script>
    let scene,camera,renderer,wallGrids,verticalLines,horizontalLines,floorGrid,raisedFloor;
    let waterGeom,waterMesh;
    let orientationOffsetQuat=new THREE.Quaternion();
    let lastQuat=new THREE.Quaternion();
    let offsetInitialized=false;
    let isCalibrated=false;
    let targetAngles={alpha:0,beta:0,gamma:0};
    let currentAngles={alpha:0,beta:0,gamma:0};
    const strongTimeDefault=1.0; // seconds to reach ~63% of target on main axis
    const weakTimeDefault=0.3;   // quicker response on other axes
    const strongTimeCalibrated=2.0; // stronger stabilization after calibration
    const weakTimeCalibrated=0.6;
    let explosions=[];
    let fallingTiles=[];
    let floatingItems=[];
    let bombs=[];
    let nextBombTime=0;
    let lastTime=performance.now()*0.001;
    const orientDisplay=document.getElementById('orientDisplay');
    const fpsDisplay=document.getElementById('fpsDisplay');
    const stepsDisplay=document.getElementById('stepsDisplay');
    const energyDisplay=document.getElementById('energyDisplay');
    const energyBar=document.getElementById('energyBar');
    const chargeBtn=document.getElementById('chargeBtn');
    const targetLock=document.getElementById('targetLock');
    const sceneCanvas=document.getElementById('sceneCanvas');
    let charging=false;
    chargeBtn.addEventListener('mousedown',()=>charging=true);
    chargeBtn.addEventListener('mouseup',()=>charging=false);
    chargeBtn.addEventListener('mouseleave',()=>charging=false);
    chargeBtn.addEventListener('touchstart',()=>{charging=true;});
    chargeBtn.addEventListener('touchend',()=>{charging=false;});
    chargeBtn.addEventListener('touchcancel',()=>{charging=false;});
    sceneCanvas.addEventListener('click',e=>{showTargetLock(e.clientX,e.clientY);fireMissile();});
    sceneCanvas.addEventListener('touchstart',e=>{const t=e.touches[0];showTargetLock(t.clientX,t.clientY);fireMissile();e.preventDefault();});
    let stepCount=0;
    let lastStepTime=0;
    let energy=0;
    const MAX_ENERGY=10;
    const GRAVITY=9.8;
    const raycaster=new THREE.Raycaster();
    const clickPlane=new THREE.Plane(new THREE.Vector3(0,1,0),0);
    const ROOM_SIZE=30;
    const GRID_SPACING=10;
    function initScene(){
      scene=new THREE.Scene();
      scene.background=new THREE.Color(0x000000);
      camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      camera.position.set(0,1.5,5);
      renderer=new THREE.WebGLRenderer({canvas:document.getElementById('sceneCanvas'),antialias:true});
      renderer.setSize(window.innerWidth,window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      scene.add(new THREE.AmbientLight(0x404040));
      const light=new THREE.PointLight(0xffffff,1,100);
      light.position.set(0,5,0);
      scene.add(light);
      const sun=new THREE.DirectionalLight(0xffffff,0.8);
      sun.position.set(5,10,2);
      scene.add(sun);

      const floorSize=ROOM_SIZE;
      const floorDiv=30;
      const floorMat=new THREE.LineBasicMaterial({color:0xff8800,opacity:0.4,transparent:true});
      floorGrid=new THREE.GridHelper(floorSize,floorDiv,0xff8800,0x884400);
      floorGrid.material=floorMat;
      scene.add(floorGrid);

      const platformHeight=GRID_SPACING*0.22;
      const tileCount=10;
      const tileSize=floorSize/tileCount;
      const layers=3;
      const layerSpacing=platformHeight+0.5;
      raisedFloor=new THREE.Group();
      for(let l=0;l<layers;l++){
        for(let i=0;i<tileCount;i++){
          for(let j=0;j<tileCount;j++){
            const geo=new THREE.BoxGeometry(tileSize,platformHeight,tileSize);
            const mat=new THREE.MeshBasicMaterial({color:0x555555});
            const tile=new THREE.Mesh(geo,mat);
            const edges=new THREE.EdgesGeometry(geo);
            const lineMat=new THREE.LineBasicMaterial({color:0xffffff});
            const line=new THREE.LineSegments(edges,lineMat);
            tile.add(line);
            tile.position.set(
              -floorSize/2+tileSize/2+i*tileSize,
              platformHeight/2+l*layerSpacing,
              -floorSize/2+tileSize/2+j*tileSize
            );
            tile.userData.baseColor=0x555555;
            tile.userData.alive=true;
            tile.userData.falling=false;
            tile.userData.height=platformHeight;
            tile.userData.size=tileSize;
            raisedFloor.add(tile);
          }
        }
      }
      raisedFloor.position.y=GRID_SPACING*0.33;
      scene.add(raisedFloor);

      wallGrids=new THREE.Group();
      const wallSize=ROOM_SIZE;
      const wallDiv=30;
      const wallMat=new THREE.LineBasicMaterial({color:0x00ffff,opacity:0.2,transparent:true});
      const front=new THREE.GridHelper(wallSize,wallDiv,0x00ffff,0x008888);front.rotation.x=Math.PI/2;front.position.z=-wallSize/2;front.position.y=wallSize/2;front.material=wallMat.clone();wallGrids.add(front);
      const back=new THREE.GridHelper(wallSize,wallDiv,0x00ffff,0x008888);back.rotation.x=Math.PI/2;back.position.z=wallSize/2;back.position.y=wallSize/2;back.material=wallMat.clone();wallGrids.add(back);
      const left=new THREE.GridHelper(wallSize,wallDiv,0x00ffff,0x008888);left.rotation.z=Math.PI/2;left.position.x=-wallSize/2;left.position.y=wallSize/2;left.material=wallMat.clone();wallGrids.add(left);
      const right=new THREE.GridHelper(wallSize,wallDiv,0x00ffff,0x008888);right.rotation.z=Math.PI/2;right.position.x=wallSize/2;right.position.y=wallSize/2;right.material=wallMat.clone();wallGrids.add(right);
      const ceiling=new THREE.GridHelper(floorSize,floorDiv,0x00ffff,0x008888);ceiling.position.y=wallSize;ceiling.material=floorMat.clone();ceiling.material.opacity=0.2;wallGrids.add(ceiling);
      scene.add(wallGrids);

      createVerticalLines();
      createHorizontalLines();
      createWaterSurface();
      createFloatingItems();
      window.addEventListener('resize',onResize);
      window.addEventListener('orientationchange',onResize);
      renderer.domElement.addEventListener('click',handleClick);
    }

    function showTargetLock(x,y){
      targetLock.style.left=(x-10)+'px';
      targetLock.style.top=(y-10)+'px';
      targetLock.style.display='block';
      setTimeout(()=>targetLock.style.display='none',300);
    }

    function fireMissile(){
      if(energy<=0) return;
      energy--;
      const dir=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
      raycaster.set(camera.position,dir);
      let point=null;
      let target=null;
      const intersects=raycaster.intersectObjects([waterMesh,raisedFloor],true);
      if(intersects.length>0){
        point=intersects[0].point.clone();
        const obj=intersects[0].object;
        target=(obj===waterMesh)?'water':'floor';
      }else{
        point=new THREE.Vector3();
        raycaster.ray.intersectPlane(clickPlane,point);
      }
      createExplosion(point,target);
    }

    function createVerticalLines(){
      const gridExtent=ROOM_SIZE/2;
      const height=ROOM_SIZE;
      const step=GRID_SPACING;
      const offset=step/2;
      const vertices=[];
      for(let x=-gridExtent+offset;x<=gridExtent;x+=step){
        for(let z=-gridExtent+offset;z<=gridExtent;z+=step){
          vertices.push(x,0,z);
          vertices.push(x,height,z);
        }
      }
      const geo=new THREE.BufferGeometry();
      geo.setAttribute('position',new THREE.Float32BufferAttribute(vertices,3));
      const mat=new THREE.LineBasicMaterial({color:0xff00ff,opacity:0.6,transparent:true,depthWrite:false});
      verticalLines=new THREE.LineSegments(geo,mat);
      verticalLines.renderOrder=1;
      scene.add(verticalLines);
    }

    function createHorizontalLines(){
      const gridExtent=ROOM_SIZE/2;
      const step=GRID_SPACING;
      const levels=[step/2, ROOM_SIZE/2, ROOM_SIZE-step/2];
      const vertices=[];
      for(const y of levels){
        for(let x=-gridExtent;x<=gridExtent;x+=step){
          vertices.push(x,y,-gridExtent);
          vertices.push(x,y,gridExtent);
        }
        for(let z=-gridExtent;z<=gridExtent;z+=step){
          vertices.push(-gridExtent,y,z);
          vertices.push(gridExtent,y,z);
        }
      }
      const geo=new THREE.BufferGeometry();
      geo.setAttribute('position',new THREE.Float32BufferAttribute(vertices,3));
      const mat=new THREE.LineBasicMaterial({color:0xff00ff,opacity:0.4,transparent:true,depthWrite:false});
      horizontalLines=new THREE.LineSegments(geo,mat);
      horizontalLines.renderOrder=1;
      scene.add(horizontalLines);
    }

      function createWaterSurface(){
        const size=ROOM_SIZE;
        const segments=50;
        waterGeom=new THREE.PlaneGeometry(size,size,segments,segments);
        waterGeom.rotateX(-Math.PI/2);
        const colors=new Float32Array(waterGeom.attributes.position.count*3);
        const baseColor=new THREE.Color(0x888888);
        for(let i=0;i<waterGeom.attributes.position.count;i++){
          colors[i*3]=baseColor.r;
          colors[i*3+1]=baseColor.g;
          colors[i*3+2]=baseColor.b;
        }
        waterGeom.setAttribute('color',new THREE.Float32BufferAttribute(colors,3));
        const mat=new THREE.MeshBasicMaterial({vertexColors:true,transparent:true,opacity:0.6});
        waterMesh=new THREE.Mesh(waterGeom,mat);
        waterMesh.position.y=-0.01;
        waterMesh.userData.baseColor=colors.slice();
        scene.add(waterMesh);
      }

      function createFloatingItems(){
        const count=8;
        const geo=new THREE.IcosahedronGeometry(0.3,1);
        for(let i=0;i<count;i++){
          const mat=new THREE.MeshStandardMaterial({color:0xffee00});
          const item=new THREE.Mesh(geo,mat);
          item.position.set(
            (Math.random()-0.5)*ROOM_SIZE*0.8,
            0,
            (Math.random()-0.5)*ROOM_SIZE*0.8
          );
          floatingItems.push(item);
          scene.add(item);
        }
      }

    function onResize(){
      camera.aspect=window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }

    function calibrateOrientation(){
      orientationOffsetQuat.copy(lastQuat);
      offsetInitialized=true;
      isCalibrated=true;
    }

    function computeWaterHeight(x,z,time){
      const wave1=Math.sin(x*0.5+time)*0.6;
      const wave2=Math.cos(z*0.7+time*1.3)*0.6;
      const radial=Math.sin(Math.hypot(x,z)*0.2-time*1.5)*0.3;
      return wave1+wave2+radial;
    }

      function updateWaterSurface(time){
        if(!waterGeom) return;
        const pos=waterGeom.attributes.position;
        for(let i=0;i<pos.count;i++){
          const x=pos.getX(i);
          const z=pos.getZ(i);
          pos.setY(i,computeWaterHeight(x,z,time));
        }
        pos.needsUpdate=true;
        waterGeom.computeVertexNormals();
      }

      function updateFloatingItems(time){
        floatingItems.forEach((item,i)=>{
          const h=computeWaterHeight(item.position.x,item.position.z,time);
          item.position.y=h+0.2+Math.sin(time*2+i)*0.1;
          item.rotation.y+=0.01;
        });
      }

      function updateRaisedFloor(time){
        if(!raisedFloor) return;
        const t=(Math.sin(time)+1)/2;
        const base=GRID_SPACING*0.33;
        const amp=GRID_SPACING*0.33;
        raisedFloor.position.y=base+amp*t;
        const hue=(time*0.2)%1;
        raisedFloor.children.forEach(tile=>{
          if(tile.userData.falling) return;
          tile.material.color.setHSL(hue,1,0.5);
        });
      }

      function updateFallingTiles(delta){
        for(let i=fallingTiles.length-1;i>=0;i--){
          const tile=fallingTiles[i];
          tile.position.addScaledVector(tile.userData.velocity,delta);
          tile.userData.velocity.y-=GRAVITY*delta;
          const half=(tile.userData.height||tile.geometry.parameters.height)/2;
          const sizeHalf=(tile.userData.size||1)/2;
          if(tile.position.y<half){
            tile.position.y=half;
            tile.userData.velocity.y*=-0.7;
            tile.userData.velocity.x*=0.9;
            tile.userData.velocity.z*=0.9;
            if(Math.abs(tile.userData.velocity.y)<0.1){
              tile.userData.velocity.y=0;
            }
          }
          const limit=ROOM_SIZE/2-sizeHalf;
          if(tile.position.x<-limit || tile.position.x>limit){
            tile.position.x=THREE.MathUtils.clamp(tile.position.x,-limit,limit);
            tile.userData.velocity.x*=-0.7;
          }
          if(tile.position.z<-limit || tile.position.z>limit){
            tile.position.z=THREE.MathUtils.clamp(tile.position.z,-limit,limit);
            tile.userData.velocity.z*=-0.7;
          }
          if(tile.position.y<=half && tile.userData.velocity.length()<0.05){
            fallingTiles.splice(i,1);
          }
        }
      }

      function spawnBomb(){
        const geo=new THREE.SphereGeometry(0.35,16,16);
        const mat=new THREE.MeshStandardMaterial({color:0x333333});
        const bomb=new THREE.Mesh(geo,mat);
        bomb.position.set(
          (Math.random()-0.5)*ROOM_SIZE*0.9,
          ROOM_SIZE,
          (Math.random()-0.5)*ROOM_SIZE*0.9
        );
        bomb.userData.velocity=new THREE.Vector3(0,-5-Math.random()*5,0);
        bombs.push(bomb);
        scene.add(bomb);
      }

      function updateBombs(delta,time){
        if(time>nextBombTime){
          spawnBomb();
          nextBombTime=time+2+Math.random()*4;
        }
        for(let i=bombs.length-1;i>=0;i--){
          const b=bombs[i];
          b.position.addScaledVector(b.userData.velocity,delta);
          b.userData.velocity.y-=GRAVITY*delta;
          if(b.position.y<=0){
            createExplosion(b.position,'water');
            scene.remove(b);
            b.geometry.dispose();
            b.material.dispose();
            bombs.splice(i,1);
          }
        }
      }

      function handleClick(event){
        const rect=renderer.domElement.getBoundingClientRect();
        const mouse=new THREE.Vector2(
          ((event.clientX-rect.left)/rect.width)*2-1,
          -((event.clientY-rect.top)/rect.height)*2+1
        );
        raycaster.setFromCamera(mouse,camera);
        let point=null;
        let target=null; // 'water' or 'floor'
        const intersects=raycaster.intersectObjects([waterMesh,raisedFloor],true);
        if(intersects.length>0){
          point=intersects[0].point.clone();
          const obj=intersects[0].object;
          target=(obj===waterMesh)?'water':'floor';
        }else{
          point=new THREE.Vector3();
          raycaster.ray.intersectPlane(clickPlane,point);
        }
        createExplosion(point,target);
      }

      function createExplosion(position,target){
        const geom=new THREE.BufferGeometry().setFromPoints(Array.from({length:65},(_,i)=>{
          const a=i/64*Math.PI*2;
          return new THREE.Vector3(Math.cos(a),0,Math.sin(a));
        }));
        const mat=new THREE.LineBasicMaterial({color:0xffff00,transparent:true});
        const ring=new THREE.LineLoop(geom,mat);
        ring.rotation.x=-Math.PI/2;
        ring.position.copy(position);
        const start=performance.now()*0.001;
        scene.add(ring);
        explosions.push({ring,center:position.clone(),start,affected:new Set(),target});
      }

      function updateExplosions(time){
        resetDistortion();
        for(let i=explosions.length-1;i>=0;i--){
          const exp=explosions[i];
          const t=time-exp.start;
          exp.ring.scale.setScalar(1+t*5);
          exp.ring.material.opacity=Math.max(0,1-t*0.5);
          applyDistortion(exp.center,t,exp);
          if(t>2){
            scene.remove(exp.ring);
            exp.ring.geometry.dispose();
            exp.ring.material.dispose();
            exp.affected.forEach(tile=>{
              const worldPos=tile.getWorldPosition(new THREE.Vector3());
              raisedFloor.remove(tile);
              tile.position.copy(worldPos);
              tile.material.color.set(tile.userData.baseColor);
              tile.userData.alive=false;
              tile.userData.falling=true;
              tile.userData.velocity=new THREE.Vector3(
                (tile.position.x-exp.center.x),
                4+Math.random()*2,
                (tile.position.z-exp.center.z)
              );
              scene.add(tile);
              fallingTiles.push(tile);
            });
            explosions.splice(i,1);
          }
        }
      }

      function resetDistortion(){
        if(waterGeom && waterGeom.userData.base){
          const pos=waterGeom.attributes.position;
          const base=waterGeom.userData.base;
          const colors=waterGeom.attributes.color;
          const baseCol=waterMesh.userData.baseColor;
          for(let i=0;i<pos.count;i++){
            pos.setXYZ(i,base[i*3],base[i*3+1],base[i*3+2]);
            colors.setXYZ(i,baseCol[i*3],baseCol[i*3+1],baseCol[i*3+2]);
          }
          pos.needsUpdate=true;
          colors.needsUpdate=true;
        }
      }

      function applyDistortion(center,t,exp){
        const radius=t*5;
        const floorRadius=Math.min(radius,3); // limit floor effect
        const strength=Math.max(0,1-t*0.5)*0.5;
        if((!exp.target || exp.target==='water') && waterGeom){
          const pos=waterGeom.attributes.position;
          const colors=waterGeom.attributes.color;
          if(!waterGeom.userData.base) waterGeom.userData.base=pos.array.slice();
          if(!waterMesh.userData.baseColor) waterMesh.userData.baseColor=colors.array.slice();
          const base=waterGeom.userData.base;
          const baseCol=waterMesh.userData.baseColor;
          for(let i=0;i<pos.count;i++){
            const bx=base[i*3];
            const by=base[i*3+1];
            const bz=base[i*3+2];
            const dist=Math.hypot(bx-center.x,bz-center.z);
            let y=by;
            if(dist<radius){
              y+= (radius-dist)/radius*strength;
              colors.setXYZ(i,1,0,0);
            }else{
              colors.setXYZ(i,baseCol[i*3],baseCol[i*3+1],baseCol[i*3+2]);
            }
            pos.setXYZ(i,bx,y,bz);
          }
          pos.needsUpdate=true;
          colors.needsUpdate=true;
          waterGeom.computeVertexNormals();
        }
        if((!exp.target || exp.target==='floor') && raisedFloor){
          const MAX_REMOVALS=5;
          raisedFloor.children.forEach(tile=>{
            if(!tile.userData.alive) return;
            const worldPos=tile.getWorldPosition(new THREE.Vector3());
            const dist=Math.hypot(worldPos.x-center.x,worldPos.z-center.z);
            if(dist<floorRadius){
              tile.material.color.set(0xff0000);
              if(exp && (exp.affected.has(tile) || exp.affected.size<MAX_REMOVALS)){
                exp.affected.add(tile);
              }
            }else{
              tile.material.color.set(tile.userData.baseColor);
            }
          });
        }
      }

    function handleOrientation(e){
      // store target angles in degrees for smoothing later
      targetAngles.alpha=e.alpha||0;
      targetAngles.beta=e.beta||0;
      targetAngles.gamma=e.gamma||0;

      // compute quaternion from raw data for calibration
      const r=Math.PI/180;
      const orient=(screen.orientation&&typeof screen.orientation.angle==='number')
        ?THREE.MathUtils.degToRad(screen.orientation.angle)
        : (typeof window.orientation==='number'?THREE.MathUtils.degToRad(window.orientation):0);
      const euler=new THREE.Euler();
      const zee=new THREE.Vector3(0,0,1);
      const q0=new THREE.Quaternion();
      const q1=new THREE.Quaternion(-Math.sqrt(0.5),0,0,Math.sqrt(0.5));
      euler.set(targetAngles.beta*r,targetAngles.alpha*r,-targetAngles.gamma*r,'YXZ');
      const quaternion=new THREE.Quaternion().setFromEuler(euler);
      quaternion.multiply(q1);
      quaternion.multiply(q0.setFromAxisAngle(zee,-orient));
      lastQuat.copy(quaternion);
      if(!offsetInitialized){orientationOffsetQuat.copy(quaternion);offsetInitialized=true;}
    }

    function handleMotion(e){
      const acc=e.accelerationIncludingGravity;
      if(!acc) return;
      const accMag=Math.sqrt(acc.x*acc.x+acc.y*acc.y+acc.z*acc.z);
      const deltaAcc=accMag-GRAVITY;
      const now=performance.now();
      if(deltaAcc>1.2&&now-lastStepTime>300){
        stepCount++;
        if(charging && energy<MAX_ENERGY) energy++;
        lastStepTime=now;
      }
    }

    function startOrientation(){
      window.addEventListener('deviceorientation',handleOrientation);
      window.addEventListener('devicemotion',handleMotion);
      document.getElementById('calibrateBtn').style.display='block';
    }

    function requestPermission(){
      const promises=[];
      if(typeof DeviceOrientationEvent!=='undefined'&&typeof DeviceOrientationEvent.requestPermission==='function'){
        promises.push(DeviceOrientationEvent.requestPermission());
      }
      if(typeof DeviceMotionEvent!=='undefined'&&typeof DeviceMotionEvent.requestPermission==='function'){
        promises.push(DeviceMotionEvent.requestPermission());
      }
      if(promises.length>0){
        Promise.all(promises).then(res=>{
          if(res.every(r=>r==='granted')){
            startOrientation();
            document.getElementById('permissionBtn').style.display='none';
          }
        }).catch(console.error);
      }else{
        startOrientation();
        document.getElementById('permissionBtn').style.display='none';
      }
    }

    function animate(){
      requestAnimationFrame(animate);
      const time=performance.now()*0.001;
      const delta=time-lastTime;
      lastTime=time;
      // determine which axis to heavily stabilize based on screen orientation
      const orientDeg=(screen.orientation&&typeof screen.orientation.angle==='number')
        ?screen.orientation.angle
        : (typeof window.orientation==='number'?window.orientation:0);
      const strongAxis=(orientDeg===0||orientDeg===180)?'beta':'alpha';
      const st=isCalibrated?strongTimeCalibrated:strongTimeDefault;
      const wt=isCalibrated?weakTimeCalibrated:weakTimeDefault;
      const factorStrong=1-Math.exp(-delta/st);
      const factorWeak=1-Math.exp(-delta/wt);
      ['alpha','beta','gamma'].forEach(ax=>{
        const f=ax===strongAxis?factorStrong:factorWeak;
        currentAngles[ax]+= (targetAngles[ax]-currentAngles[ax])*f;
      });

      orientDisplay.textContent=`α:${currentAngles.alpha.toFixed(1)} β:${currentAngles.beta.toFixed(1)} γ:${currentAngles.gamma.toFixed(1)}`;
      fpsDisplay.textContent=`FPS: ${(1/delta).toFixed(1)}`;
      stepsDisplay.textContent=`Steps: ${stepCount}`;
      energyDisplay.textContent=`Energy: ${energy}`;
      const energyPercent=energy/MAX_ENERGY;
      energyBar.style.width=(energyPercent*100)+'%';
      energyBar.style.backgroundColor=`hsl(${energyPercent*120},100%,50%)`;

      const r=Math.PI/180;
      const orientRad=THREE.MathUtils.degToRad(orientDeg);
      const euler=new THREE.Euler();
      const zee=new THREE.Vector3(0,0,1);
      const q0=new THREE.Quaternion();
      const q1=new THREE.Quaternion(-Math.sqrt(0.5),0,0,Math.sqrt(0.5));
      euler.set(currentAngles.beta*r,currentAngles.alpha*r,-currentAngles.gamma*r,'YXZ');
      const quaternion=new THREE.Quaternion().setFromEuler(euler);
      quaternion.multiply(q1);
      quaternion.multiply(q0.setFromAxisAngle(zee,-orientRad));
      const calibrated=quaternion.clone().premultiply(orientationOffsetQuat.clone().invert());
      camera.quaternion.copy(calibrated);

      updateWaterSurface(time);
      updateRaisedFloor(time);
      updateFloatingItems(time);
      updateBombs(delta,time);
      updateExplosions(time);
      updateFallingTiles(delta);
      renderer.render(scene,camera);
    }

    window.addEventListener('load',()=>{
      initScene();
      animate();
      const btn=document.getElementById('permissionBtn');
      const calib=document.getElementById('calibrateBtn');
      calib.addEventListener('click',calibrateOrientation);
      const needsPerm=(typeof DeviceOrientationEvent!=='undefined'&&typeof DeviceOrientationEvent.requestPermission==='function')||
                      (typeof DeviceMotionEvent!=='undefined'&&typeof DeviceMotionEvent.requestPermission==='function');
      if(needsPerm){
        btn.style.display='block';
        btn.addEventListener('click',requestPermission);
      }else{
        startOrientation();
      }
    });
  </script>
</body>
</html>
