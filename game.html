<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GAME v033blocks</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body,html{margin:0;padding:0;overflow:hidden;background:#000;}
    #sceneCanvas{display:block;width:100vw;height:100vh;}
    #permissionBtn{position:absolute;top:20px;left:20px;padding:10px 20px;font-family:sans-serif;font-size:16px;}
  </style>
</head>
<body>
  <canvas id="sceneCanvas"></canvas>
  <button id="permissionBtn" style="display:none;">Enable Motion</button>
  <button id="calibrateBtn" style="display:none;top:60px;left:20px;position:absolute;padding:10px 20px;font-family:sans-serif;font-size:16px;">Calibrate</button>
  <script>
    let scene,camera,renderer,wallGrids,verticalLines,horizontalLines,floorGrid,raisedFloor;
    let waterGeom,waterMesh;
    let orientationOffsetQuat=new THREE.Quaternion();
    let lastQuat=new THREE.Quaternion();
    let offsetInitialized=false;
    let lastTime=performance.now()*0.001;
    const GRAVITY=9.8;
    const ROOM_SIZE=30;
    const GRID_SPACING=10;
    function initScene(){
      scene=new THREE.Scene();
      scene.background=new THREE.Color(0x000000);
      camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      camera.position.set(0,1.5,5);
      renderer=new THREE.WebGLRenderer({canvas:document.getElementById('sceneCanvas'),antialias:true});
      renderer.setSize(window.innerWidth,window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      scene.add(new THREE.AmbientLight(0x404040));
      const light=new THREE.PointLight(0xffffff,1,100);
      light.position.set(0,5,0);
      scene.add(light);
      const sun=new THREE.DirectionalLight(0xffffff,0.8);
      sun.position.set(5,10,2);
      scene.add(sun);

      const floorSize=ROOM_SIZE;
      const floorDiv=30;
      const floorMat=new THREE.LineBasicMaterial({color:0xff8800,opacity:0.4,transparent:true});
      floorGrid=new THREE.GridHelper(floorSize,floorDiv,0xff8800,0x884400);
      floorGrid.material=floorMat;
      scene.add(floorGrid);

      const platformHeight=GRID_SPACING*0.11;
      const tileCount=10;
      const step=floorSize/tileCount;
      const gap=0.2;
      const tileSize=step-gap;
      raisedFloor=new THREE.Group();
      for(let i=0;i<tileCount;i++){
        for(let j=0;j<tileCount;j++){
          const geo=new THREE.BoxGeometry(tileSize,platformHeight,tileSize);
          const mat=new THREE.MeshBasicMaterial({color:0x555555});
          const tile=new THREE.Mesh(geo,mat);
          const edges=new THREE.EdgesGeometry(geo);
          const lineMat=new THREE.LineBasicMaterial({color:0xffffff});
          const line=new THREE.LineSegments(edges,lineMat);
          tile.add(line);
          tile.position.set(
            -floorSize/2+step/2+i*step,
            platformHeight/2,
            -floorSize/2+step/2+j*step
          );
          tile.userData.baseColor=0x555555;
          tile.userData.alive=true;
          tile.userData.falling=false;
          tile.userData.height=platformHeight;
          raisedFloor.add(tile);
        }
      }
      raisedFloor.position.y=GRID_SPACING*0.33;
      scene.add(raisedFloor);

      wallGrids=new THREE.Group();
      const wallSize=ROOM_SIZE;
      const wallDiv=30;
      const wallMat=new THREE.LineBasicMaterial({color:0x00ffff,opacity:0.2,transparent:true});
      const front=new THREE.GridHelper(wallSize,wallDiv,0x00ffff,0x008888);front.rotation.x=Math.PI/2;front.position.z=-wallSize/2;front.position.y=wallSize/2;front.material=wallMat.clone();wallGrids.add(front);
      const back=new THREE.GridHelper(wallSize,wallDiv,0x00ffff,0x008888);back.rotation.x=Math.PI/2;back.position.z=wallSize/2;back.position.y=wallSize/2;back.material=wallMat.clone();wallGrids.add(back);
      const left=new THREE.GridHelper(wallSize,wallDiv,0x00ffff,0x008888);left.rotation.z=Math.PI/2;left.position.x=-wallSize/2;left.position.y=wallSize/2;left.material=wallMat.clone();wallGrids.add(left);
      const right=new THREE.GridHelper(wallSize,wallDiv,0x00ffff,0x008888);right.rotation.z=Math.PI/2;right.position.x=wallSize/2;right.position.y=wallSize/2;right.material=wallMat.clone();wallGrids.add(right);
      const ceiling=new THREE.GridHelper(floorSize,floorDiv,0x00ffff,0x008888);ceiling.position.y=wallSize;ceiling.material=floorMat.clone();ceiling.material.opacity=0.2;wallGrids.add(ceiling);
      scene.add(wallGrids);

      createVerticalLines();
      createHorizontalLines();
      createWaterSurface();
      window.addEventListener('resize',onResize);
      window.addEventListener('orientationchange',onResize);
    }

    function createVerticalLines(){
      const gridExtent=ROOM_SIZE/2;
      const height=ROOM_SIZE;
      const step=GRID_SPACING;
      const offset=step/2;
      const vertices=[];
      for(let x=-gridExtent+offset;x<=gridExtent;x+=step){
        for(let z=-gridExtent+offset;z<=gridExtent;z+=step){
          vertices.push(x,0,z);
          vertices.push(x,height,z);
        }
      }
      const geo=new THREE.BufferGeometry();
      geo.setAttribute('position',new THREE.Float32BufferAttribute(vertices,3));
      const mat=new THREE.LineBasicMaterial({color:0xff00ff,opacity:0.6,transparent:true,depthWrite:false});
      verticalLines=new THREE.LineSegments(geo,mat);
      verticalLines.renderOrder=1;
      scene.add(verticalLines);
    }

    function createHorizontalLines(){
      const gridExtent=ROOM_SIZE/2;
      const step=GRID_SPACING;
      const levels=[step/2, ROOM_SIZE/2, ROOM_SIZE-step/2];
      const vertices=[];
      for(const y of levels){
        for(let x=-gridExtent;x<=gridExtent;x+=step){
          vertices.push(x,y,-gridExtent);
          vertices.push(x,y,gridExtent);
        }
        for(let z=-gridExtent;z<=gridExtent;z+=step){
          vertices.push(-gridExtent,y,z);
          vertices.push(gridExtent,y,z);
        }
      }
      const geo=new THREE.BufferGeometry();
      geo.setAttribute('position',new THREE.Float32BufferAttribute(vertices,3));
      const mat=new THREE.LineBasicMaterial({color:0xff00ff,opacity:0.4,transparent:true,depthWrite:false});
      horizontalLines=new THREE.LineSegments(geo,mat);
      horizontalLines.renderOrder=1;
      scene.add(horizontalLines);
    }

      function createWaterSurface(){
        const size=ROOM_SIZE;
        const segments=50;
        waterGeom=new THREE.PlaneGeometry(size,size,segments,segments);
        waterGeom.rotateX(-Math.PI/2);
        const colors=new Float32Array(waterGeom.attributes.position.count*3);
        const baseColor=new THREE.Color(0x888888);
        for(let i=0;i<waterGeom.attributes.position.count;i++){
          colors[i*3]=baseColor.r;
          colors[i*3+1]=baseColor.g;
          colors[i*3+2]=baseColor.b;
        }
        waterGeom.setAttribute('color',new THREE.Float32BufferAttribute(colors,3));
        const mat=new THREE.MeshBasicMaterial({vertexColors:true,transparent:true,opacity:0.6});
        waterMesh=new THREE.Mesh(waterGeom,mat);
        waterMesh.position.y=-0.01;
        waterMesh.userData.baseColor=colors.slice();
        scene.add(waterMesh);
      }


    function onResize(){
      camera.aspect=window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }

    function calibrateOrientation(){
      orientationOffsetQuat.copy(lastQuat);
      offsetInitialized=true;
    }

    function computeWaterHeight(x,z,time){
      const wave1=Math.sin(x*0.5+time)*0.6;
      const wave2=Math.cos(z*0.7+time*1.3)*0.6;
      const radial=Math.sin(Math.hypot(x,z)*0.2-time*1.5)*0.3;
      return wave1+wave2+radial;
    }

      function updateWaterSurface(time){
        if(!waterGeom) return;
        const pos=waterGeom.attributes.position;
        for(let i=0;i<pos.count;i++){
          const x=pos.getX(i);
          const z=pos.getZ(i);
          pos.setY(i,computeWaterHeight(x,z,time));
        }
        pos.needsUpdate=true;
        waterGeom.computeVertexNormals();
      }


      function updateRaisedFloor(time){
        if(!raisedFloor) return;
        const t=(Math.sin(time)+1)/2;
        const base=GRID_SPACING*0.33;
        const amp=GRID_SPACING*0.33;
        raisedFloor.position.y=base+amp*t;
        const hue=(time*0.2)%1;
        raisedFloor.children.forEach(tile=>{
          if(tile.userData.falling) return;
          tile.material.color.setHSL(hue,1,0.5);
        });
      }



    function handleOrientation(e){
      const raw={alpha:e.alpha||0,beta:e.beta||0,gamma:e.gamma||0};
      const r=Math.PI/180;
      const alpha=raw.alpha*r;
      const beta=raw.beta*r;
      const gamma=raw.gamma*r;
      const orient=(screen.orientation&&typeof screen.orientation.angle==='number')
        ?THREE.MathUtils.degToRad(screen.orientation.angle)
        : (typeof window.orientation==='number'?THREE.MathUtils.degToRad(window.orientation):0);
      const euler=new THREE.Euler();
      const zee=new THREE.Vector3(0,0,1);
      const q0=new THREE.Quaternion();
      const q1=new THREE.Quaternion(-Math.sqrt(0.5),0,0,Math.sqrt(0.5));
      euler.set(beta,alpha,-gamma,'YXZ');
      const quaternion=new THREE.Quaternion().setFromEuler(euler);
      quaternion.multiply(q1);
      quaternion.multiply(q0.setFromAxisAngle(zee,-orient));
      lastQuat.copy(quaternion);
      if(!offsetInitialized){orientationOffsetQuat.copy(quaternion);offsetInitialized=true;}
      const calibrated=quaternion.clone().premultiply(orientationOffsetQuat.clone().invert());
      camera.quaternion.slerp(calibrated,0.2);
    }

    function startOrientation(){
      window.addEventListener('deviceorientation',handleOrientation);
      document.getElementById('calibrateBtn').style.display='block';
    }

    function requestPermission(){
      if(typeof DeviceOrientationEvent!=='undefined'&&typeof DeviceOrientationEvent.requestPermission==='function'){
        DeviceOrientationEvent.requestPermission().then(state=>{if(state==='granted'){startOrientation();document.getElementById('permissionBtn').style.display='none';}}).catch(console.error);
      }
    }

    function animate(){
      requestAnimationFrame(animate);
      const time=performance.now()*0.001;
      const delta=time-lastTime;
      lastTime=time;
        updateWaterSurface(time);
        updateRaisedFloor(time);
        renderer.render(scene,camera);
      }

    window.addEventListener('load',()=>{
      initScene();
      animate();
      const btn=document.getElementById('permissionBtn');
      const calib=document.getElementById('calibrateBtn');
      calib.addEventListener('click',calibrateOrientation);
      if(typeof DeviceOrientationEvent!=='undefined'&&typeof DeviceOrientationEvent.requestPermission==='function'){
        btn.style.display='block';
        btn.addEventListener('click',requestPermission);
      }else{
        startOrientation();
      }
    });
  </script>
</body>
</html>
