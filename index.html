<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Game Hub v0.22</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 1.25rem;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: sans-serif;
      background: radial-gradient(circle at 20% 30%, #1c2a52, #0a0f1f 60%),
        radial-gradient(circle at 80% 10%, #243b68, transparent 50%),
        linear-gradient(135deg, #0a1029, #09101d 70%, #04060f);
      color: #fff;
      text-align: center;
      overflow: hidden;
      box-sizing: border-box;
    }

    main {
      width: 100%;
      max-width: 1180px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.35rem;
      padding: 0.75rem 1rem 1.35rem;
      background: rgba(0, 8, 20, 0.58);
      box-shadow: 0 10px 45px rgba(0, 0, 0, 0.35), 0 0 60px rgba(26, 123, 255, 0.2);
      backdrop-filter: blur(6px);
      border-radius: 16px;
    }

    h1 {
      font-size: clamp(2.85rem, 4.8vw, 4.5rem);
      letter-spacing: 3px;
      margin: 0;
      text-transform: uppercase;
      color: #d4e6ff;
      text-shadow: 0 0 10px rgba(76, 168, 255, 0.9), 0 0 24px rgba(0, 180, 255, 0.45), 0 12px 32px rgba(0, 0, 0, 0.6);
      position: relative;
    }

    h1::after {
      content: '';
      position: absolute;
      left: 50%;
      bottom: -12px;
      transform: translateX(-50%);
      width: 160px;
      height: 3px;
      background: linear-gradient(90deg, transparent, rgba(0, 200, 255, 0.9), transparent);
      box-shadow: 0 0 14px rgba(0, 200, 255, 0.75);
    }

    .canvas-frame {
      position: relative;
      width: 100%;
      height: 55vh;
      min-height: 340px;
      overflow: hidden;
      box-shadow: 0 16px 50px rgba(0, 0, 0, 0.5), 0 0 60px rgba(26, 123, 255, 0.2);
      background: linear-gradient(135deg, rgba(20, 35, 70, 0.85), rgba(10, 18, 36, 0.85));
      border-radius: 12px;
    }

    #bg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .vector-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: screen;
      opacity: 0.65;
      filter: drop-shadow(0 0 10px rgba(0, 200, 255, 0.6));
    }

    .vector-overlay svg {
      width: 100%;
      height: 100%;
    }

    .vector-overlay line,
    .vector-overlay polyline {
      stroke: rgba(0, 210, 255, 0.9);
      stroke-width: 1.4;
      stroke-linecap: round;
      stroke-linejoin: round;
      stroke-dasharray: 10 6;
      animation: dash 6s linear infinite;
    }

    .vector-overlay polyline {
      stroke: rgba(255, 80, 140, 0.85);
    }

    @keyframes dash {
      to {
        stroke-dashoffset: -320;
      }
    }

    .cta-buttons {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.65rem;
      pointer-events: none;
      padding: 0.5rem;
    }

    .info {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0;
      max-width: 780px;
    }

    p {
      margin: 0;
      color: #c8d7ff;
      letter-spacing: 0.3px;
      text-shadow: 0 0 12px rgba(100, 180, 255, 0.35);
    }

    .cta-buttons a {
      pointer-events: auto;
      display: inline-block;
      padding: 0.55rem 1.2rem;
      background: linear-gradient(120deg, #ff9800, #ff5722 40%, #ff3d7f);
      color: #fff;
      text-decoration: none;
      font-size: 1.05rem;
      letter-spacing: 0.5px;
      transition: transform 0.25s ease, box-shadow 0.25s ease, background 0.3s;
      box-shadow: 0 8px 22px rgba(255, 87, 34, 0.3);
      border-radius: 10px;
      min-width: 9rem;
      width: min(18rem, 90vw);
      text-align: center;
    }

    .cta-buttons a:hover {
      background: linear-gradient(120deg, #ffc107, #ff7043 40%, #ff4da6);
      transform: translateY(-1px) scale(1.01);
      box-shadow: 0 12px 28px rgba(255, 105, 71, 0.4);
    }

    .cta-buttons a.secondary {
      background: linear-gradient(120deg, #4fc3f7, #00bcd4 40%, #5c6bc0);
      box-shadow: 0 8px 22px rgba(0, 188, 212, 0.28);
    }

    .cta-buttons a.secondary:hover {
      background: linear-gradient(120deg, #81d4fa, #26c6da 40%, #7986cb);
      box-shadow: 0 12px 28px rgba(0, 188, 212, 0.4);
    }

    @media (max-width: 980px) {
      body {
        padding: 1rem;
        align-items: flex-start;
      }

      main {
        padding: 0.85rem 0.85rem 1.45rem;
        gap: 0.5rem;
      }

      h1 {
        letter-spacing: 2px;
      }

      .canvas-frame {
        height: 52vh;
        min-height: 300px;
      }

      .cta-buttons {
        gap: 0.55rem;
      }

      .cta-buttons a {
        font-size: 1rem;
        padding: 0.65rem 1.1rem;
      }
    }

    @media (max-width: 540px) {
      body {
        padding: 0.85rem;
      }

      main {
        padding: 0.75rem 0.65rem 1.2rem;
        border-radius: 14px;
      }

      h1 {
        font-size: clamp(2.15rem, 9vw, 3.2rem);
        letter-spacing: 1.5px;
      }

      .canvas-frame {
        height: 48vh;
        min-height: 260px;
        border-radius: 10px;
      }

      .cta-buttons {
        padding: 0.75rem;
      }

      .cta-buttons a {
        width: 100%;
        max-width: 360px;
      }

      p {
        font-size: 0.98rem;
      }
    }
  </style>
</head>
<body>
  <main>
    <h1>Neon Game Hub</h1>
    <div class="canvas-frame">
      <canvas id="bg"></canvas>
      <div class="vector-overlay" aria-hidden="true">
        <svg viewBox="0 0 100 100" preserveAspectRatio="none">
          <line x1="5" y1="10" x2="95" y2="30"></line>
          <line x1="10" y1="80" x2="90" y2="65"></line>
          <line x1="15" y1="20" x2="35" y2="95"></line>
          <line x1="70" y1="10" x2="55" y2="90"></line>
          <polyline points="5,60 25,40 45,60 65,42 85,58" fill="none"></polyline>
          <polyline points="15,15 40,8 68,22 88,12" fill="none"></polyline>
        </svg>
      </div>
      <div class="cta-buttons">
        <a class="play-button" href="game.html">Play Now</a>
        <a class="secondary" href="terrain.html">Explorer Mode</a>
        <a class="secondary" href="#arena">Arena Mode</a>
      </div>
    </div>
    <div class="info">
      <p>Prepare yourself for an immersive 3D experience.</p>
    </div>
  </main>
  <script>
    const canvas = document.getElementById('bg');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050913, 0.035);

    const camera = new THREE.PerspectiveCamera(62, 1, 0.1, 180);
    camera.position.set(0, 8, 18);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.75));
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;

    const clock = new THREE.Clock();
    const root = new THREE.Group();
    scene.add(root);

    // Atmosphere + light
    const ambient = new THREE.AmbientLight(0x5fb1ff, 0.4);
    scene.add(ambient);

    const mainLight = new THREE.PointLight(0xffbf7f, 2.8, 120, 1.8);
    mainLight.position.set(-12, 18, 10);
    scene.add(mainLight);

    const rimLight = new THREE.PointLight(0x6ac7ff, 1.4, 90, 2);
    rimLight.position.set(14, 10, -12);
    scene.add(rimLight);

    function makeFlare(color) {
      const size = 256;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
      gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0.9)`);
      gradient.addColorStop(0.35, `rgba(${color.r}, ${color.g}, ${color.b}, 0.45)`);
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, size, size);
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(20, 20, 1);
      return sprite;
    }

    const warmFlare = makeFlare({ r: 255, g: 170, b: 100 });
    warmFlare.position.copy(mainLight.position).multiplyScalar(0.6);
    scene.add(warmFlare);

    const coolFlare = makeFlare({ r: 120, g: 190, b: 255 });
    coolFlare.position.copy(rimLight.position).multiplyScalar(0.65);
    scene.add(coolFlare);

    // Low-poly terrain
    const terrainGeometry = new THREE.PlaneGeometry(60, 60, 90, 90);
    const pos = terrainGeometry.attributes.position;
    for (let i = 0; i < pos.count; i++) {
      const x = pos.getX(i);
      const z = pos.getZ(i);
      const height = Math.sin(x * 0.22) * 1.6 + Math.cos(z * 0.18) * 1.2 + (Math.random() * 0.8 - 0.4);
      pos.setY(i, height);
    }
    pos.needsUpdate = true;
    terrainGeometry.computeVertexNormals();
    terrainGeometry.rotateX(-Math.PI / 2);

    const terrainMaterial = new THREE.MeshStandardMaterial({
      color: 0x0d203f,
      roughness: 0.95,
      metalness: 0.05,
      flatShading: true,
      emissive: 0x071022,
      emissiveIntensity: 0.4,
    });
    const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
    terrain.receiveShadow = true;
    root.add(terrain);

    // Crystal monoliths
    const crystals = new THREE.Group();
    const crystalMaterial = new THREE.MeshStandardMaterial({
      color: 0x1c8adb,
      emissive: 0x133d6a,
      emissiveIntensity: 0.65,
      metalness: 0.3,
      roughness: 0.25,
      flatShading: true,
    });

    const crystalSpin = [];
    for (let i = 0; i < 30; i++) {
      const geom = new THREE.DodecahedronGeometry(THREE.MathUtils.randFloat(0.35, 1.6), 0);
      const mesh = new THREE.Mesh(geom, crystalMaterial);
      const angle = Math.random() * Math.PI * 2;
      const radius = 6 + Math.random() * 18;
      const y = THREE.MathUtils.randFloat(0.3, 2.8);
      mesh.position.set(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
      mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
      crystalSpin.push(0.002 + Math.random() * 0.001);
      crystals.add(mesh);
    }
    root.add(crystals);

    // Floating shards
    const shardMaterial = new THREE.MeshStandardMaterial({
      color: 0xffc857,
      emissive: 0x753900,
      emissiveIntensity: 0.5,
      flatShading: true,
      metalness: 0.2,
      roughness: 0.4,
    });
    const shardGeometry = new THREE.TetrahedronGeometry(THREE.MathUtils.randFloat(0.12, 0.35), 0);
    const shardCount = 140;
    const shardMesh = new THREE.InstancedMesh(shardGeometry, shardMaterial, shardCount);
    shardMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    root.add(shardMesh);

    const shardStates = [];
    const shardDummy = new THREE.Object3D();
    for (let i = 0; i < shardCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const radius = 8 + Math.random() * 18;
      const baseY = THREE.MathUtils.randFloat(1.4, 8.5);
      shardDummy.position.set(Math.cos(angle) * radius, baseY, Math.sin(angle) * radius);
      shardDummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
      shardDummy.updateMatrix();
      shardMesh.setMatrixAt(i, shardDummy.matrix);
      shardStates.push({
        x: shardDummy.position.x,
        y: baseY,
        z: shardDummy.position.z,
        baseRot: shardDummy.rotation.clone(),
        floatSpeed: 1.2 + Math.random() * 0.8,
        floatAmp: THREE.MathUtils.randFloat(0.35, 0.9),
        spinX: 0.0035 + Math.random() * 0.0012,
        spinY: 0.0042 + Math.random() * 0.0014,
        offset: Math.random() * Math.PI * 2,
      });
    }

    // Star particles
    const starGeom = new THREE.BufferGeometry();
    const starCount = 320;
    const starPositions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount * 3; i += 3) {
      starPositions[i] = THREE.MathUtils.randFloatSpread(80);
      starPositions[i + 1] = THREE.MathUtils.randFloat(10, 40);
      starPositions[i + 2] = THREE.MathUtils.randFloatSpread(80);
    }
    starGeom.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const starMat = new THREE.PointsMaterial({ color: 0xcfe3ff, size: 0.2, transparent: true, opacity: 0.9, depthWrite: false });
    const stars = new THREE.Points(starGeom, starMat);
    root.add(stars);

    let lastWidth = 0;
    let lastHeight = 0;
    let needsResize = true;
    function sizeRendererToCanvas(force = false) {
      if (!force && !needsResize) return;
      const { width, height } = canvas.getBoundingClientRect();
      if (width !== lastWidth || height !== lastHeight || force) {
        lastWidth = width;
        lastHeight = height;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height, false);
      }
      needsResize = false;
    }

    sizeRendererToCanvas(true);
    window.addEventListener('resize', () => {
      needsResize = true;
    });

    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();

      sizeRendererToCanvas();

      camera.position.x = Math.sin(t * 0.15) * 16;
      camera.position.z = Math.cos(t * 0.12) * 18;
      camera.position.y = 6 + Math.sin(t * 0.35) * 1.8;
      camera.lookAt(0, 2.5 + Math.sin(t * 0.2) * 0.5, 0);

      terrain.rotation.y = t * 0.0015;
      crystals.children.forEach((c, i) => {
        const spin = crystalSpin[i];
        c.rotation.y += spin;
        c.position.y += Math.sin(t * 0.65 + i) * 0.0012;
      });

      for (let i = 0; i < shardCount; i++) {
        const state = shardStates[i];
        const y = state.y + Math.sin(t * state.floatSpeed + state.offset) * state.floatAmp;
        shardDummy.position.set(state.x, y, state.z);
        shardDummy.rotation.set(
          state.baseRot.x + t * state.spinX,
          state.baseRot.y + t * state.spinY,
          state.baseRot.z
        );
        shardDummy.updateMatrix();
        shardMesh.setMatrixAt(i, shardDummy.matrix);
      }
      shardMesh.instanceMatrix.needsUpdate = true;

      const flarePulse = (Math.sin(t * 2.0) + 1) * 0.35 + 0.4;
      warmFlare.material.opacity = flarePulse;
      coolFlare.material.opacity = 0.3 + Math.sin(t * 1.3 + 1) * 0.25;

      stars.rotation.y += 0.0005;

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
