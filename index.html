<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon Game Hub v0.22</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      font-family: sans-serif;
      background: radial-gradient(circle at 20% 30%, #1c2a52, #0a0f1f 60%),
        radial-gradient(circle at 80% 10%, #243b68, transparent 50%),
        linear-gradient(135deg, #0a1029, #09101d 70%, #04060f);
      background-color: #04060f;
      color: #fff;
      text-align: center;
      overflow-x: hidden;
      overflow-y: auto;
      touch-action: pan-y;
      -webkit-overflow-scrolling: touch;
      box-sizing: border-box;
    }

    main {
      width: 100vw;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 0;
      padding: 0;
      background: rgba(0, 8, 20, 0.58);
      box-shadow: none;
      backdrop-filter: blur(6px);
      border-radius: 0;
    }

    h1 {
      font-size: clamp(2.85rem, 4.8vw, 4.5rem);
      letter-spacing: 3px;
      margin: 0;
      text-transform: uppercase;
      color: #d4e6ff;
      text-shadow: 0 0 10px rgba(76, 168, 255, 0.9), 0 0 24px rgba(0, 180, 255, 0.45), 0 12px 32px rgba(0, 0, 0, 0.6);
      position: relative;
    }

    h1::after {
      content: '';
      position: absolute;
      left: 50%;
      bottom: -12px;
      transform: translateX(-50%);
      width: 160px;
      height: 3px;
      background: linear-gradient(90deg, transparent, rgba(0, 200, 255, 0.9), transparent);
      box-shadow: 0 0 14px rgba(0, 200, 255, 0.75);
    }

    .canvas-frame {
      position: relative;
      width: 100vw;
      height: 100vh;
      min-height: 360px;
      overflow: hidden;
      box-shadow: none;
      background: linear-gradient(135deg, rgba(20, 35, 70, 0.85), rgba(10, 18, 36, 0.85));
      border-radius: 0;
    }

    .fullscreen-toggle {
      position: absolute;
      top: 0.65rem;
      right: 0.65rem;
      padding: 0.45rem 0.8rem;
      background: rgba(0, 0, 0, 0.45);
      border: 1px solid rgba(0, 200, 255, 0.35);
      color: #d4e6ff;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.95rem;
      letter-spacing: 0.35px;
      backdrop-filter: blur(6px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
      transition: transform 0.2s ease, border-color 0.2s ease, color 0.2s ease;
      pointer-events: auto;
    }

    .fullscreen-toggle:hover,
    .fullscreen-toggle:focus-visible {
      transform: translateY(-1px) scale(1.01);
      border-color: rgba(0, 200, 255, 0.7);
      color: #fff;
      outline: none;
    }

    #bg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .vector-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: screen;
      opacity: 0.78;
      filter: drop-shadow(0 0 12px rgba(0, 200, 255, 0.35));
    }

    .vector-overlay svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .grid-layer rect {
      fill: url(#neon-grid);
      opacity: 0.55;
      filter: blur(0.35px);
      animation: grid-flicker 6.5s ease-in-out infinite;
    }

    .grid-layer .axis {
      stroke: rgba(0, 230, 255, 0.75);
      stroke-width: 0.6;
      stroke-linecap: round;
      filter: drop-shadow(0 0 6px rgba(0, 200, 255, 0.45));
      animation: axis-pulse 5.5s ease-in-out infinite;
    }

    .wired-paths polyline {
      stroke: rgba(255, 128, 196, 0.9);
      stroke-width: 0.9;
      stroke-linecap: round;
      stroke-linejoin: round;
      fill: none;
      filter: blur(0.4px) drop-shadow(0 0 10px rgba(255, 128, 196, 0.35));
      stroke-dasharray: 18 12;
      animation: wire-glow 7s ease-in-out infinite;
    }

    .wired-paths polyline:nth-child(2) {
      stroke: rgba(130, 210, 255, 0.9);
      stroke-dasharray: 16 9;
      animation-duration: 6.4s;
    }

    .wired-paths polyline:nth-child(3) {
      stroke: rgba(0, 255, 205, 0.75);
      stroke-dasharray: 14 10;
      animation-duration: 8.2s;
    }

    @keyframes grid-flicker {
      0% {
        opacity: 0.35;
        filter: blur(0.7px);
      }
      30% {
        opacity: 0.55;
        filter: blur(0.3px);
      }
      55% {
        opacity: 0.72;
        filter: blur(0.1px);
      }
      100% {
        opacity: 0.4;
        filter: blur(0.6px);
      }
    }

    @keyframes axis-pulse {
      0%,
      100% {
        opacity: 0.75;
      }
      50% {
        opacity: 0.45;
        stroke-width: 0.45;
      }
    }

    @keyframes wire-glow {
      0% {
        opacity: 0.2;
        stroke-dashoffset: 0;
        filter: blur(0.7px) drop-shadow(0 0 12px rgba(255, 128, 196, 0.45));
      }
      40% {
        opacity: 0.68;
        stroke-dashoffset: -22;
        filter: blur(0.35px) drop-shadow(0 0 14px rgba(255, 128, 196, 0.55));
      }
      70% {
        opacity: 0.5;
        stroke-dashoffset: -36;
        filter: blur(0.55px) drop-shadow(0 0 18px rgba(255, 128, 196, 0.35));
      }
      100% {
        opacity: 0.26;
        stroke-dashoffset: -12;
      }
    }

    .cta-buttons {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.65rem;
      pointer-events: none;
      padding: 0.5rem;
    }

    .info {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0;
      max-width: 780px;
      padding: 1rem 1.25rem 1.5rem;
    }

    p {
      margin: 0;
      color: #c8d7ff;
      letter-spacing: 0.3px;
      text-shadow: 0 0 12px rgba(100, 180, 255, 0.35);
    }

    .cta-buttons a {
      pointer-events: auto;
      display: inline-block;
      padding: 0.55rem 1.2rem;
      background: linear-gradient(120deg, #ff9800, #ff5722 40%, #ff3d7f);
      color: #fff;
      text-decoration: none;
      font-size: 1.05rem;
      letter-spacing: 0.5px;
      transition: transform 0.25s ease, box-shadow 0.25s ease, background 0.3s;
      box-shadow: 0 8px 22px rgba(255, 87, 34, 0.3);
      border-radius: 10px;
      min-width: 9rem;
      width: min(18rem, 90vw);
      text-align: center;
    }

    .cta-buttons a:hover {
      background: linear-gradient(120deg, #ffc107, #ff7043 40%, #ff4da6);
      transform: translateY(-1px) scale(1.01);
      box-shadow: 0 12px 28px rgba(255, 105, 71, 0.4);
    }

    .cta-buttons a.secondary {
      background: linear-gradient(120deg, #4fc3f7, #00bcd4 40%, #5c6bc0);
      box-shadow: 0 8px 22px rgba(0, 188, 212, 0.28);
    }

    .cta-buttons a.secondary:hover {
      background: linear-gradient(120deg, #81d4fa, #26c6da 40%, #7986cb);
      box-shadow: 0 12px 28px rgba(0, 188, 212, 0.4);
    }

    .arena-section {
      position: relative;
      width: 100vw;
      min-height: 80vh;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: radial-gradient(circle at 10% 10%, rgba(0, 200, 255, 0.1), transparent 40%),
        radial-gradient(circle at 85% 20%, rgba(255, 99, 146, 0.1), transparent 32%),
        linear-gradient(135deg, #05080f, #0a0f1f 60%, #03060c);
    }

    #arenaCanvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #050910;
    }

    .arena-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      padding: 1.25rem 1.5rem;
      gap: 1rem;
      pointer-events: none;
    }

    .arena-copy {
      max-width: 520px;
      text-align: left;
    }

    .arena-sub {
      margin-top: 0.15rem;
      color: #cddcf9;
    }

    .eyebrow {
      font-size: 0.82rem;
      letter-spacing: 0.28rem;
      text-transform: uppercase;
      color: rgba(140, 198, 255, 0.9);
      margin: 0 0 0.2rem;
    }

    h2 {
      margin: 0;
      font-size: clamp(2rem, 3.8vw, 3rem);
      letter-spacing: 0.08em;
      text-shadow: 0 0 16px rgba(76, 168, 255, 0.35);
    }

    .arena-hud {
      display: inline-flex;
      gap: 1rem;
      padding: 0.75rem 1rem;
      background: rgba(0, 8, 18, 0.65);
      border: 1px solid rgba(0, 200, 255, 0.35);
      border-radius: 10px;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.4);
      pointer-events: none;
    }

    .hud-label {
      display: block;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: rgba(200, 220, 255, 0.8);
    }

    .hud-value {
      display: block;
      font-weight: 700;
      font-size: 1.3rem;
      letter-spacing: 0.08em;
    }

    @media (max-width: 980px) {
      body {
        align-items: flex-start;
      }

      main {
        gap: 0.5rem;
      }

      h1 {
        letter-spacing: 2px;
      }

      .canvas-frame {
        height: 82vh;
        min-height: 320px;
      }

      .cta-buttons {
        gap: 0.55rem;
      }

      .fullscreen-toggle {
        top: 0.55rem;
        right: 0.55rem;
        font-size: 0.9rem;
        padding: 0.4rem 0.7rem;
      }

      .cta-buttons a {
        font-size: 1rem;
        padding: 0.65rem 1.1rem;
      }

      .arena-overlay {
        flex-direction: column;
        align-items: flex-start;
        padding: 1rem;
      }

      .arena-hud {
        width: auto;
      }
    }

    @media (max-width: 540px) {
      main {
        border-radius: 0;
      }

      h1 {
        font-size: clamp(2.15rem, 9vw, 3.2rem);
        letter-spacing: 1.5px;
      }

      .canvas-frame {
        height: 70vh;
        min-height: 260px;
        border-radius: 0;
      }

      .cta-buttons {
        padding: 0.75rem;
      }

      .fullscreen-toggle {
        top: 0.5rem;
        right: 0.5rem;
        font-size: 0.85rem;
      }

      .arena-overlay {
        padding: 0.85rem;
      }

      .arena-hud {
        flex-direction: column;
        gap: 0.5rem;
      }

      .cta-buttons a {
        width: 100%;
        max-width: 360px;
      }

      p {
        font-size: 0.98rem;
      }
    }
  </style>
</head>
<body>
  <main>
    <h1>Neon Game Hub</h1>
    <div class="canvas-frame">
      <button class="fullscreen-toggle" type="button" aria-pressed="false">Enter Fullscreen</button>
      <canvas id="bg"></canvas>
      <div class="vector-overlay" aria-hidden="true">
        <svg viewBox="0 0 100 100" preserveAspectRatio="none">
          <defs>
            <pattern id="neon-grid" width="8" height="8" patternUnits="userSpaceOnUse">
              <path d="M0 0 L0 8 M0 0 L8 0" fill="none" stroke="rgba(0, 200, 255, 0.5)" stroke-width="0.3" />
            </pattern>
          </defs>
          <g class="grid-layer">
            <rect x="0" y="0" width="100" height="100"></rect>
            <line class="axis" x1="0" y1="50" x2="100" y2="50"></line>
            <line class="axis" x1="50" y1="0" x2="50" y2="100"></line>
          </g>
          <g class="wired-paths">
            <polyline points="8,72 22,60 38,66 52,52 74,62 88,50"></polyline>
            <polyline points="12,32 30,22 48,30 62,18 82,26 90,16"></polyline>
            <polyline points="6,46 18,40 28,48 44,34 58,40 70,30 86,36"></polyline>
          </g>
        </svg>
      </div>
      <div class="cta-buttons">
        <a class="play-button" href="game.html">Play Now</a>
        <a class="secondary" href="terrain.html">Explorer Mode</a>
        <a class="secondary" href="#arena">Arena Mode</a>
      </div>
    </div>
    <div class="info">
      <p>Prepare yourself for an immersive 3D experience.</p>
    </div>
    <section id="arena" class="arena-section">
      <canvas id="arenaCanvas"></canvas>
      <div class="arena-overlay">
        <div class="arena-copy">
          <p class="eyebrow">Arena Mode</p>
          <h2>Low-Poly City Explorer</h2>
          <p class="arena-sub">Prototype your open-world plans in a compact neon city. Drive the scout rig with WASD and sweep the skyline.</p>
        </div>
        <div class="arena-hud">
          <div>
            <span class="hud-label">Speed</span>
            <span class="hud-value" data-arena-speed>0</span>
          </div>
          <div>
            <span class="hud-label">Heading</span>
            <span class="hud-value" data-arena-heading>0°</span>
          </div>
        </div>
      </div>
    </section>
  </main>
  <script>
    const canvas = document.getElementById('bg');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050913, 0.035);

    const camera = new THREE.PerspectiveCamera(62, 1, 0.1, 180);
    camera.position.set(0, 8, 18);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;

    const clock = new THREE.Clock();
    const root = new THREE.Group();
    scene.add(root);

    // Atmosphere + light
    const ambient = new THREE.AmbientLight(0x5fb1ff, 0.4);
    scene.add(ambient);

    const mainLight = new THREE.PointLight(0xffbf7f, 2.8, 120, 1.8);
    mainLight.position.set(-12, 18, 10);
    scene.add(mainLight);

    const rimLight = new THREE.PointLight(0x6ac7ff, 1.4, 90, 2);
    rimLight.position.set(14, 10, -12);
    scene.add(rimLight);

    function makeFlare(color) {
      const size = 256;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
      gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0.9)`);
      gradient.addColorStop(0.35, `rgba(${color.r}, ${color.g}, ${color.b}, 0.45)`);
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, size, size);
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(20, 20, 1);
      return sprite;
    }

    const warmFlare = makeFlare({ r: 255, g: 170, b: 100 });
    warmFlare.position.copy(mainLight.position).multiplyScalar(0.6);
    scene.add(warmFlare);

    const coolFlare = makeFlare({ r: 120, g: 190, b: 255 });
    coolFlare.position.copy(rimLight.position).multiplyScalar(0.65);
    scene.add(coolFlare);

    // Low-poly terrain
    const terrainGeometry = new THREE.PlaneGeometry(60, 60, 90, 90);
    const pos = terrainGeometry.attributes.position;
    for (let i = 0; i < pos.count; i++) {
      const x = pos.getX(i);
      const z = pos.getZ(i);
      const height = Math.sin(x * 0.22) * 1.6 + Math.cos(z * 0.18) * 1.2 + (Math.random() * 0.8 - 0.4);
      pos.setY(i, height);
    }
    pos.needsUpdate = true;
    terrainGeometry.computeVertexNormals();
    terrainGeometry.rotateX(-Math.PI / 2);

    const terrainMaterial = new THREE.MeshStandardMaterial({
      color: 0x0d203f,
      roughness: 0.95,
      metalness: 0.05,
      flatShading: true,
      emissive: 0x071022,
      emissiveIntensity: 0.4,
    });
    const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
    terrain.receiveShadow = true;
    root.add(terrain);

    // Crystal monoliths
    const crystals = new THREE.Group();
    const crystalMaterial = new THREE.MeshStandardMaterial({
      color: 0x1c8adb,
      emissive: 0x133d6a,
      emissiveIntensity: 0.65,
      metalness: 0.3,
      roughness: 0.25,
      flatShading: true,
    });

    const crystalSpin = [];
    for (let i = 0; i < 30; i++) {
      const geom = new THREE.DodecahedronGeometry(THREE.MathUtils.randFloat(0.35, 1.6), 0);
      const mesh = new THREE.Mesh(geom, crystalMaterial);
      const angle = Math.random() * Math.PI * 2;
      const radius = 6 + Math.random() * 18;
      const y = THREE.MathUtils.randFloat(0.3, 2.8);
      mesh.position.set(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
      mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
      crystalSpin.push(0.002 + Math.random() * 0.001);
      crystals.add(mesh);
    }
    root.add(crystals);

    // Floating shards
    const shardMaterial = new THREE.MeshStandardMaterial({
      color: 0xffc857,
      emissive: 0x753900,
      emissiveIntensity: 0.5,
      flatShading: true,
      metalness: 0.2,
      roughness: 0.4,
    });
    const shardGeometry = new THREE.TetrahedronGeometry(THREE.MathUtils.randFloat(0.12, 0.35), 0);
    const shardCount = 120;
    const shardMesh = new THREE.InstancedMesh(shardGeometry, shardMaterial, shardCount);
    shardMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    root.add(shardMesh);

    const shardStates = [];
    const shardDummy = new THREE.Object3D();
    for (let i = 0; i < shardCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const radius = 8 + Math.random() * 18;
      const baseY = THREE.MathUtils.randFloat(1.4, 8.5);
      shardDummy.position.set(Math.cos(angle) * radius, baseY, Math.sin(angle) * radius);
      shardDummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
      shardDummy.updateMatrix();
      shardMesh.setMatrixAt(i, shardDummy.matrix);
      shardStates.push({
        x: shardDummy.position.x,
        y: baseY,
        z: shardDummy.position.z,
        baseRot: shardDummy.rotation.clone(),
        floatSpeed: 1.2 + Math.random() * 0.8,
        floatAmp: THREE.MathUtils.randFloat(0.35, 0.9),
        spinX: 0.0035 + Math.random() * 0.0012,
        spinY: 0.0042 + Math.random() * 0.0014,
        offset: Math.random() * Math.PI * 2,
      });
    }

    // Star particles
    const starGeom = new THREE.BufferGeometry();
    const starCount = 240;
    const starPositions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount * 3; i += 3) {
      starPositions[i] = THREE.MathUtils.randFloatSpread(80);
      starPositions[i + 1] = THREE.MathUtils.randFloat(10, 40);
      starPositions[i + 2] = THREE.MathUtils.randFloatSpread(80);
    }
    starGeom.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const starMat = new THREE.PointsMaterial({ color: 0xcfe3ff, size: 0.2, transparent: true, opacity: 0.9, depthWrite: false });
    const stars = new THREE.Points(starGeom, starMat);
    root.add(stars);

    // Arena mode scene
    const arenaCanvas = document.getElementById('arenaCanvas');
    const arenaScene = new THREE.Scene();
    arenaScene.fog = new THREE.Fog(0x0a111f, 18, 180);

    const arenaCamera = new THREE.PerspectiveCamera(65, 1, 0.1, 400);
    arenaCamera.position.set(0, 8, 18);

    const arenaRenderer = new THREE.WebGLRenderer({ canvas: arenaCanvas, antialias: true });
    arenaRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.6));
    arenaRenderer.outputEncoding = THREE.sRGBEncoding;
    arenaRenderer.toneMapping = THREE.ACESFilmicToneMapping;

    const arenaAmbient = new THREE.AmbientLight(0x6fa6ff, 0.35);
    arenaScene.add(arenaAmbient);

    const arenaKey = new THREE.DirectionalLight(0x9ad8ff, 1.2);
    arenaKey.position.set(-20, 30, 10);
    arenaScene.add(arenaKey);

    const arenaRim = new THREE.DirectionalLight(0xff7a9e, 0.65);
    arenaRim.position.set(22, 18, -12);
    arenaScene.add(arenaRim);

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(400, 400),
      new THREE.MeshStandardMaterial({ color: 0x0a1222, roughness: 1, metalness: 0, side: THREE.DoubleSide })
    );
    ground.rotation.x = -Math.PI / 2;
    arenaScene.add(ground);

    const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x0b0f16, roughness: 0.85, metalness: 0.05 });
    const roadWidth = 6;
    const roadLength = 400;
    const roadGeoH = new THREE.BoxGeometry(roadLength, 0.08, roadWidth);
    const roadGeoV = new THREE.BoxGeometry(roadWidth, 0.08, roadLength);
    for (let i = -6; i <= 6; i++) {
      const roadH = new THREE.Mesh(roadGeoH, roadMaterial);
      roadH.position.z = i * 14;
      arenaScene.add(roadH);

      const roadV = new THREE.Mesh(roadGeoV, roadMaterial);
      roadV.position.x = i * 14;
      arenaScene.add(roadV);
    }

    const dividerMat = new THREE.LineBasicMaterial({ color: 0x1b2b44, transparent: true, opacity: 0.6 });
    const dividerGeo = new THREE.BufferGeometry();
    const dividerVerts = [];
    for (let i = -roadLength / 2; i <= roadLength / 2; i += 4) {
      dividerVerts.push(-roadLength / 2, 0.06, i, roadLength / 2, 0.06, i);
      dividerVerts.push(i, 0.06, -roadLength / 2, i, 0.06, roadLength / 2);
    }
    dividerGeo.setAttribute('position', new THREE.Float32BufferAttribute(dividerVerts, 3));
    const dividerLines = new THREE.LineSegments(dividerGeo, dividerMat);
    arenaScene.add(dividerLines);

    const buildingGroup = new THREE.Group();
    arenaScene.add(buildingGroup);
    const palette = [0x1c2f4a, 0x243a63, 0x2f4b7a, 0x234061, 0x1b2d43];

    function addBuilding(x, z) {
      const w = 4 + Math.random() * 4;
      const d = 4 + Math.random() * 4;
      const h = 3 + Math.random() * 14;
      const geometry = new THREE.BoxGeometry(w, h, d);
      const color = palette[Math.floor(Math.random() * palette.length)];
      const material = new THREE.MeshStandardMaterial({
        color,
        emissive: 0x0b1a2c,
        emissiveIntensity: 0.25 + Math.random() * 0.2,
        metalness: 0.25,
        roughness: 0.55,
        flatShading: true,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(x, h / 2, z);
      mesh.castShadow = false;
      mesh.receiveShadow = true;
      buildingGroup.add(mesh);

      if (Math.random() > 0.6) {
        const antenna = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.15, h * 0.25, 6),
          new THREE.MeshStandardMaterial({ color: 0x5cf0ff, emissive: 0x5cf0ff, emissiveIntensity: 0.6, roughness: 0.2 })
        );
        antenna.position.set(0, h / 2 + h * 0.125, 0);
        mesh.add(antenna);
      }
    }

    const gridSize = 6;
    const spacing = 14;
    for (let gx = -gridSize; gx <= gridSize; gx++) {
      for (let gz = -gridSize; gz <= gridSize; gz++) {
        if (gx % 2 === 0 || gz % 2 === 0) continue;
        const jitterX = (Math.random() - 0.5) * 3;
        const jitterZ = (Math.random() - 0.5) * 3;
        addBuilding(gx * spacing + jitterX, gz * spacing + jitterZ);
      }
    }

    const plazaGeometry = new THREE.CircleGeometry(8, 32);
    const plaza = new THREE.Mesh(
      plazaGeometry,
      new THREE.MeshStandardMaterial({ color: 0x0f1c2e, emissive: 0x0c1a2b, roughness: 0.75 })
    );
    plaza.rotation.x = -Math.PI / 2;
    plaza.position.set(0, 0.02, 0);
    arenaScene.add(plaza);

    const plazaGlow = new THREE.PointLight(0x3fc3ff, 1.5, 24, 2.5);
    plazaGlow.position.set(0, 2.4, 0);
    arenaScene.add(plazaGlow);

    const explorer = new THREE.Group();
    const hull = new THREE.Mesh(
      new THREE.BoxGeometry(1.4, 0.6, 2.2),
      new THREE.MeshStandardMaterial({
        color: 0x1bb4ff,
        emissive: 0x0c2847,
        emissiveIntensity: 0.7,
        metalness: 0.45,
        roughness: 0.35,
        flatShading: true,
      })
    );
    explorer.add(hull);

    const cockpit = new THREE.Mesh(
      new THREE.BoxGeometry(1, 0.35, 0.9),
      new THREE.MeshStandardMaterial({ color: 0x8fd7ff, emissive: 0x5cc8ff, emissiveIntensity: 0.4, roughness: 0.15 })
    );
    cockpit.position.set(0, 0.25, 0.15);
    explorer.add(cockpit);

    const beacon = new THREE.PointLight(0x4ce0ff, 1.6, 18, 2.2);
    beacon.position.set(0, 0.8, 0);
    explorer.add(beacon);

    explorer.position.set(0, 0.35, 0);
    arenaScene.add(explorer);

    let explorerHeading = Math.PI;
    let explorerVelocity = 0;
    const arenaKeys = {};
    const arenaSpeedEl = document.querySelector('[data-arena-speed]');
    const arenaHeadingEl = document.querySelector('[data-arena-heading]');

    document.addEventListener('keydown', (e) => {
      arenaKeys[e.code] = true;
    });

    document.addEventListener('keyup', (e) => {
      arenaKeys[e.code] = false;
    });

    function resizeArena(force = false) {
      if (!arenaCanvas) return;
      const width = arenaCanvas.clientWidth;
      const height = arenaCanvas.clientHeight || window.innerHeight * 0.6;
      if (!width || !height) return;
      if (!force && !arenaNeedsResize) return;
      arenaCamera.aspect = width / height;
      arenaCamera.updateProjectionMatrix();
      arenaRenderer.setSize(width, height, false);
      arenaNeedsResize = false;
    }

    function updateExplorer(delta) {
      const turnRate = 1.6;
      const accel = 12;
      const brake = 8;
      if (arenaKeys['KeyA']) explorerHeading += turnRate * delta;
      if (arenaKeys['KeyD']) explorerHeading -= turnRate * delta;
      if (arenaKeys['KeyW']) explorerVelocity += accel * delta;
      if (arenaKeys['KeyS']) explorerVelocity -= brake * delta;

      explorerVelocity = THREE.MathUtils.clamp(explorerVelocity, -6, 22);
      explorerVelocity *= 1 - Math.min(1, delta * 1.2);

      const move = explorerVelocity * delta;
      explorer.position.x += Math.sin(explorerHeading) * move;
      explorer.position.z += Math.cos(explorerHeading) * move;
      explorer.position.y = 0.35 + Math.sin(performance.now() * 0.003) * 0.05;
      explorer.rotation.y = explorerHeading;

      const speedKph = Math.abs(explorerVelocity * 3.2);
      if (arenaSpeedEl) arenaSpeedEl.textContent = speedKph.toFixed(1);
      if (arenaHeadingEl) {
        const headingDeg = Math.round((explorerHeading % (Math.PI * 2)) * 180 / Math.PI + 360) % 360;
        arenaHeadingEl.textContent = `${headingDeg}°`;
      }
    }

    function updateArenaCamera(delta) {
      const followDistance = 12;
      const followHeight = 6.5;
      const offset = new THREE.Vector3(
        Math.sin(explorerHeading) * -followDistance,
        followHeight,
        Math.cos(explorerHeading) * -followDistance
      );
      const targetPos = explorer.position.clone().add(offset);
      arenaCamera.position.lerp(targetPos, 1 - Math.exp(-delta * 3));
      const lookTarget = explorer.position.clone().add(new THREE.Vector3(0, 2, 0));
      arenaCamera.lookAt(lookTarget);
    }

    let lastWidth = 0;
    let lastHeight = 0;
    let needsResize = true;
    let arenaNeedsResize = true;
    function sizeRendererToCanvas(force = false) {
      if (!force && !needsResize) return;
      const { width, height } = canvas.getBoundingClientRect();
      if (width !== lastWidth || height !== lastHeight || force) {
        lastWidth = width;
        lastHeight = height;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height, false);
      }
      needsResize = false;
    }

    sizeRendererToCanvas(true);
    resizeArena(true);
    window.addEventListener('resize', () => {
      needsResize = true;
      arenaNeedsResize = true;
    });

    // Fullscreen handling
    const fullscreenToggle = document.querySelector('.fullscreen-toggle');
    const fullscreenTarget = document.documentElement;

    function updateFullscreenLabel() {
      const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
      fullscreenToggle.textContent = isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen';
      fullscreenToggle.setAttribute('aria-pressed', isFullscreen ? 'true' : 'false');
    }

    fullscreenToggle.addEventListener('click', async () => {
      try {
        if (document.fullscreenElement || document.webkitFullscreenElement) {
          await (document.exitFullscreen || document.webkitExitFullscreen).call(document);
        } else {
          const request = fullscreenTarget.requestFullscreen || fullscreenTarget.webkitRequestFullscreen;
          if (request) {
            await request.call(fullscreenTarget);
          }
        }
      } catch (err) {
        console.error('Fullscreen toggle failed', err);
      }
    });

    document.addEventListener('fullscreenchange', updateFullscreenLabel);
    document.addEventListener('webkitfullscreenchange', updateFullscreenLabel);
    updateFullscreenLabel();

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const t = clock.elapsedTime;

      sizeRendererToCanvas();
      resizeArena();

      camera.position.x = Math.sin(t * 0.15) * 16;
      camera.position.z = Math.cos(t * 0.12) * 18;
      camera.position.y = 6 + Math.sin(t * 0.35) * 1.8;
      camera.lookAt(0, 2.5 + Math.sin(t * 0.2) * 0.5, 0);

      terrain.rotation.y = t * 0.0015;
      crystals.children.forEach((c, i) => {
        const spin = crystalSpin[i];
        c.rotation.y += spin;
        c.position.y += Math.sin(t * 0.65 + i) * 0.0012;
      });

      for (let i = 0; i < shardCount; i++) {
        const state = shardStates[i];
        const y = state.y + Math.sin(t * state.floatSpeed + state.offset) * state.floatAmp;
        shardDummy.position.set(state.x, y, state.z);
        shardDummy.rotation.set(
          state.baseRot.x + t * state.spinX,
          state.baseRot.y + t * state.spinY,
          state.baseRot.z
        );
        shardDummy.updateMatrix();
        shardMesh.setMatrixAt(i, shardDummy.matrix);
      }
      shardMesh.instanceMatrix.needsUpdate = true;

      const flarePulse = (Math.sin(t * 2.0) + 1) * 0.35 + 0.4;
      warmFlare.material.opacity = flarePulse;
      coolFlare.material.opacity = 0.3 + Math.sin(t * 1.3 + 1) * 0.25;

      stars.rotation.y += 0.0005;

      renderer.render(scene, camera);

      updateExplorer(delta);
      updateArenaCamera(delta);
      arenaRenderer.render(arenaScene, arenaCamera);
    }
    animate();
  </script>
</body>
</html>
